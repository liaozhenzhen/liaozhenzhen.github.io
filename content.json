[{"title":"Markdown的使用","date":"2017-04-09T02:42:59.000Z","path":"2017/04/09/Markdown的使用/","text":"定义Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 虽然Markdown标记语言不能够实现HTML语法上的全部功能，但可以混合使用HTML和Markdown语法。Markdown:语法提供了详细的文档。 常用语法常见的Markdown格式选项和键盘快捷键： 输出后的效果 Markdown 快捷键 bold **bold** Ctrl/⌘ + B emphasize *emphasize* Ctrl/⌘ + I Strike through ~~text~~ Ctrl + Alt + U Link [title](http:// ) Ctrl/⌘ + K Inline Code `code` Ctrl/⌘ + Shift + K Image ![alt](http:// ) Ctrl/⌘ + Shift + I Blockquote > quote Ctrl + L H1 # Heading H2 ## Heading Ctrl/⌘ + H H3 ###Heading Ctrl/⌘ + H (x2) 分割线你可以在一行中用三个以上的星号、减号、底线来建立一个分割线，行内不能有其他东西。你也可以在星号或者减号中间插入空格。下面每种写法都可以建立分割线: * * * *** ***** - - - _ 强调 Markdown使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或者 _ 包围的字体会被转成用em标签包围，用两个 * 或 _ 包起来的话，则会被转为 strong , 例如： 123456 *single asterisks* _single underscores_ **double asterisks** __double underscores__ ``` 会转成： &lt;em&gt; single asterisks&lt;/em&gt; &lt;em&gt; single underscores&lt;/em&gt; &lt;strong&gt; double asterisks&lt;/strong&gt; &lt;strong&gt; double underscores&lt;/strong&gt; ``` 你可以随时用自己喜欢的样式，唯一的限制就是：用什么符号开启标签就要用什么符号结束。","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://liaozhenzhen.github.io/tags/Markdown/"}]},{"title":"git删除远程文件","date":"2017-03-27T01:49:58.000Z","path":"2017/03/27/git-del-remote/","text":"情况最近手快，上传文件的时候忘记忽略一个不依赖的文件了，导致在git上的那个不依赖的模块占了很多空间。我就想着要把它删掉。问题来了，我不会删呐！！烦，于是昨天在问了度娘一下午，都没有很好的解决。(作者寄言：我就不信了，我还删不了你。)于是乎，今天就边操作一边记录下来。以便日后要用到。 上传以后上传某文件的时候，一定不能贪图手快。直接就全部上传了。1.比如要上传某个小项目，首先在git上新建一个项目。2.接着就需要在本地找到需要上传的项目，然后打开git 命令（git bash here）3.上传。 git init 初始化 git add -A 上传全部 git commit -m “test” 提交说明 git remote add origin +提交到git上的地址 上传到那里 git push origin master 提交接下来，输入用户和密码，就ok了。有一点值得注意如果有哪个文件不想上传，就需要在根目录下建一个.gitignore文件，在文件里面直接写上需要忽略上传的文件就好了。4.展示图一是本地文件，图二是线上文件图一：图二：好，正题开始，上传完了之后，忽然发现：啥，文件夹img居然也不小心上传了，于是，你开始想尽各种办法，把它删了。####第一种只适合那种很少文件的办法。不是要删吗，好哇，那就在git上删，只能打开文件img后一张一张图片删。说实话，耐力很好的人都会删烦。点了删除之后，还需要确认。 ####第二种我是从度娘哪里问来的。参考网址我跟着他尝试了一番，这里是说已经执行了delete，然后需要重新提交一遍。在回到git里面看，确实删掉了img文件夹。很感谢! 还有一篇很好的文章，是关于git删除文件的，里面还提示了，如果是误删该怎么解决。廖雪峰-关于删除文件","tags":[{"name":"git","slug":"git","permalink":"http://liaozhenzhen.github.io/tags/git/"}]},{"title":"设计模式之构造函数模式","date":"2017-03-22T09:56:34.000Z","path":"2017/03/22/设计模式之构造函数模式/","text":"介绍构造函数用于创建特定类型的对象——不仅声明了使用时的对象，构造函数还可以接受参数以便第一次创建对象的时候设置对象的成员值。你可以自定义自己的构造函数，然后在里面声明定义类型对象的属性或方法。 基本用法在JavaScript里，构造函数通常是认为用来实现实例的，JavaScript没有类的概念，但是有特殊的构造函数。通过new关键字来调用定义的构造函数。你可以告诉JavaScript你要创建一个新的对象并且新对象的成员声明都是构造函数里定义的。在构造函数内部，this关键字引用的是新创建的对象。基本用法如下：1234567891011121314function Car(model,year,miles)&#123; this.model=model; this.year=year; this.miles=miles; this.output=function()&#123; return this.model+&quot;走了&quot;+this.miles+&quot;公里&quot;; &#125;&#125;var zhen=new Car(&quot;purple&quot;,2017,200);var dudu=new Car(&quot;dudu&quot;,2016,3000);console.log(zhen.output()); //purple走了200公里console.log(dudu.output()); //dudu走了3000公里 上面的例子是个非常简单的构造函数模式，但是有点小问题。首先是使用继承很麻烦了，其次output()在每次创建对象的时候都重新定义了，最好的方法是让所有Car类型的实例都共享了output()方法，这样如果有大量的实例的话，就会节约很多内存。解决这个方法，我们用如下方式：1234567891011121314function Car(model,year,miles)&#123; this.model=model; this.year=year; this.miles=miles; this.output=formatCar;&#125;function formatCar()&#123; return this.model+&quot;走了&quot;+this.miles+&quot;公里&quot;;&#125;var purple=new Car(&quot;zhen&quot;,2017,200);var dudu=new Car(&quot;dudu&quot;,2016,3000);console.log(zhen.output()); //zhen走了200公里console.log(dudu.output()); //dudu走了3000公里 这个方法虽然可用，但是我们有如下更好的方式。 构造函数与原型JavaScript里函数有个属性叫做prototype，当调用构造函数创建对象的时候，所有该构造函数原型的属性在创建对象上都可用。按照这样，多个Car对象实例可以共享同一个原型，我们再扩展一下上述例子的代码：123456789101112131415161718function Car(model,year,miles)&#123; this.model=model; this.year=year; this.miles=miles;&#125;/** 注意这里我们使用了Object.prototype.方法名，而不是Object.prototype* 主要是用来避免重写定义原型prototype* */Car.prototype.output=function()&#123; return this.model+&quot;走了&quot;+this.miles+&quot;公里&quot;;&#125;;var purple=new Car(&quot;zhen&quot;,2017,200);var dudu=new Car(&quot;dudu&quot;,2016,3000);console.log(zhen.output()); //zhen走了200公里console.log(dudu.output()); //dudu走了3000公里 在这里，我们在Car的原型上增加了output()方法，这样的话，output()实例可以在多有Car对象实例里共享使用。 我们推荐构造函数以大写字母开头，以便区分普通函数。 只能用new吗？上面的例子对函数car都是用new来创建对象的，只有这一种方法吗？其实还有别的方法，我们列举两种：1234567891011121314function Car(model, year, miles)&#123; this.model = model; this.year = year; this.miles = miles; this.output = function()&#123; return this.model + &quot;走了&quot; + this.miles + &quot;公里&quot;; &#125;&#125;Car(&quot;purple&quot;, 2017, 200);console.log(window.output());var o = new Object();Car.call(o,&quot;dudu&quot;,2016,3000);console.log(o.output());/*这个例子得在浏览器上运行，如果用WebStorm直接运行的话会报错，报：ReferenceError: window is not defined*/ 改代码的方法1有点特殊，如果不是用new直接调用函数的话，this指向的是全局window，我们来验证一下：1234//作为函数调用var purple=Car(&quot;zhen&quot;,2017,200);console.log(typeof purple);//undefinedconsole.log(window.output()); //zhen走了200公里 这时候对象zhen是undefined，而window.output()会输出正确的结果，而如果使用new关键字则没有这个问题，验证如下：1234//使用new关键字var purple=new Car(&quot;zhen&quot;,2017,200);console.log(typeof purple); //objectconsole.log(purple.output()); //zhen走了200公里 强制使用new上述的例子展示了不使用new的问题，那么我们有没有办法让构造函数强制使用new关键字呢，答案是肯定的，代码如下：1234567891011121314151617function Car(model,year,miles)&#123; if(!(this instanceof Car))&#123; return new Car(model,year,miles); &#125; this.model=model; this.year=year; this.miles=miles; this.output=function()&#123; return this.model+&quot;走了&quot;+this.miles+&quot;公里&quot;; &#125;&#125;var purple=new Car(&quot;zhen&quot;,2017,200);var dudu=Car(&quot;dudu&quot;,2016,3000);console.log(typeof purple);//objectconsole.log(purple.output());//hen走了200公里console.log(typeof dudu);//objectconsole.log(dudu.output());//dudu走了3000公里 通过判断this的instanceof是不是Car来决定返回new Car还是继续执行代码，如果使用的是new关键字，则(this instanceof Car)为真，会继续执行下面的参数赋值，如果没有用new，(this instanceof Car)就为假，就会重新new一个实例返回。 原始包装函数JavaScript里有3种原始包装：Number，String，Boolean，有时候两种都用： 123456789//使用原始包装var s = new String(&quot;my string&quot;);var n = new Number(101);var b = new Boolean(true);//推荐使用这种：var s = &quot;my string&quot;;var n = 101;var b = true; 推荐，只有在想保留数值状态的时候使用这些包装函数，关于区别可以参考下面的代码：12345678910111213141516//原始stringvar greet=&quot;hello zhen&quot;;//使用split()方法分割greet.split(&quot; &quot;)[0];//&quot;hello&quot;//给原始类型添加属性不会报错greet.smile=true;//但是没法获取这个值console.log(typeof greet.smile);//undefined//原始stringvar greet=new String(&quot;hello zhen&quot;);//使用split()方法分割greet.split(&quot; &quot;)[0];//&quot;hello&quot;//给包装函数类型添加新属性不会报错greet.smile=true;console.log(typeof greet.smile);//boolean 总结本篇文章主要讲了构造函数模式的使用方法、调用方法以及new关键字的区别，希望大家在使用的时候有所注意。 参考原文","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://liaozhenzhen.github.io/tags/JavaScript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://liaozhenzhen.github.io/tags/设计模式/"}]},{"title":"关于学习新技术的10点建议","date":"2016-11-15T01:54:36.000Z","path":"2016/11/15/关于学习新技术的10点建议/","text":"我们生活在一个振奋人心的时代，我们可以越来越方便廉价的获得大量的学习资源。这些资源的传播载体由最初的教室变成了博客、技术论坛等。坐拥如此众多的学习资源，我们没有理由不去好好利用。随之而来的问题便是如何在这知识的海洋中选择自己的前进方向。 1.克服惰性 万事开头难，克服惰性是学习新技术的第一步。举个日常生活中惰性存在的例子，当我们看电视的时候会因为遥控器不在身边而懒得换台。幸运的是有很多的小技巧可以调动我们的积极性，帮助我们克服惰性。对于我来说，微习惯是一个很好用的小技巧。与其被手头的任务吓到，不如将任务细分为一个个具体的微任务，然后挑选其中的一个开始做起。就“拿遥控器” 这个例子来说，首先站起来，向遥控器的方向走去，再伸出手，遥控器就到手了。通过完成一个个的微任务，你会发现自己克服了惰性，并且这项任务不再显得难以完成。这个方法可以被应用到学习新技能的过程中。关键是将任务细分为微任务。 2.关注大牛 学习新技能的第一步是明确要学什么。它可以是任何你有激情去学，并且想深入学习的一些东西。这种原始的学习欲望非常重要，这种欲望可以在你的学习低潮给你提供动力。你想学的或许是一门新的编程语言、应用框架或者是新的工具，一旦你确定了想要的是什么，就立刻去收集相应的优秀群体所做的一些优质的工作成果。这些可以从网上、各种博客甚至是公众号那里获取。关注别人做了些什么可以给你强大的信心，让你觉得：you can do it,too! 3.建立知识网当你对自己要学的东西建立了信心之后，接下来要做的就是成为一块海绵，然后开始疯狂的吸收知识。从Google搜索关键词“菜鸟教程”开始吧，上面有很多的知识，还可以边学边测，是有助于学习的好帮手。通过浏览这些网上的资料之后，如果想要集中学习某一方面，这时就需要阅读一些相关的书籍了，个人推荐在Amazon上面寻找一些评分较高的专业书籍来提高自己。 4.多听多看随着你对技术的深入挖掘，你可能会想利用其它的方式学习，在这里有几个比较好的学习网站：中国IT实验室在这里你可以找到自己想要的资源，里面很多都是很不错的文章和知识。Scoket.IO开源社区，在这个网站里有什么问题都可以尽情的提问。里面也有很多的分类，知识划分得很好。当然如果有心学习的话，网上的资源有很多，就看你想不想学，想不想看了。 5.行动起来现在你已经看了一波又一波的教程以及视频资料，并且对于想学的技术应当有一定深入的了解了，接下来做什么呢？没错，是时候理论联系实际了，实践是检验真理的唯一标准。用你所掌握的技术做一个个人的小项目，设计一些简单的功能并实现他们。毫无疑问，你会遇到很多的绊脚石，当遇到他们的时候，在Google或者百度上面搜索，然后解决。当你遇到的困难挫折越多，你会变得更睿智。有句老话说的好，“专家是犯错最多的人”，这意味着他们尝试了很多疯狂的事情来探索这门技术的极限，最后，对于这门技术是如何运作的就可以知根知底。拥有这种洞察力之后，他们就可以随心所欲的运用这项技术去按照自己的意愿完成想做的事情。（当然，是做好的事情）。 6.写博客在你进行探险之旅的时候，实时记录下自己的成长以及犯下的错误大有裨益。在技术领域，博客是最简单易得并且受欢迎的表达载体。当你准备落笔的时候，你会强迫自己整理思路，并且对积累下来的零散的知识片段进行结构梳理。说不定，通过互联网的分享，你的经历和分享会给别人的成长带来帮助。总的来说，写博客能够提高你的沟通能力，这与你学到的技术一样重要。 7.参加聚会以及会议尽管社交网络很棒，但是没有任何事物可以取代面对面的交流。在你住的附近参加一些小组聚会，在这里你可以找到志同道合的伙伴。你可以知道他人在做的一些有趣的项目，同时也可以在他人得帮助下解决一些自己遇到的难题！同样，技术会议对于分享经验以及增长技术有帮助。 8.GitHubGitHub是全世界开源项目的标志性建筑物。它是知识以及优质代码的宝库。当你对某项技术自我感觉良好的时候，下一步便是在GitHub中浏览寻找有趣的项目。阅读开源代码，尽可能多的阅读。这样做的话，你能够学到很多东西，比如说： 1.如何管理规模较大的项目 2.项目中应用的有趣的库 3.代码规范以及代码全局设计 4.文档风格 5.测试规范 6.解决诡异问题的方法，以及发现项目中有问题的地方。所有的知识都在等着你去挖掘。有趣的是，这些知识通过一个简单的标签就可以得到，那就是“好奇心”。 9.专注学习如果你担心上述的学习过程太迟缓，那么你也尝试一下快速学习模式。我认为合理的是用几周的时间去学习。你可以尝试一下类似“七周学会七种语言”或者“七周学会七种数据库”等学习方法，但是你在学习其他技术的时候也可以运用这种思维。有一个不太相同的学习风格是“困难学习模式”，这种观点的前提是没有人可以真正掌握一门技术，除非每天都练习。所以，想要成为专家，你就需要不停地进行练习。异曲同工的是你可以查看Katas和Koans，他鼓励使用你学的知识来解决问题。这些可以让你更好的入门以及接受那些陌生的概念，勇敢走出自己的舒适区，开始学习新知识！学习一门交叉的技能。编程是一项左脑的运动，它利用的是大脑的分析能力，一步一步的寻找解决问题的方法。为了发挥右脑的功能，你可以尝试从事一些创造性的活动，比如说画画、3D建模、折纸、乐器甚至是制作家庭相册等。事实上，编程同样需要大量的创造力。或许你曾经遇到类似的事情，你在睡梦中找到了问题的解决方案。这是因为你的右脑处理问题的方式很不同，它可以从各种地方获取信息。如果你想点燃你的每一个神经元，建议你开始学习一门交叉的技能。总结掌握一门新技术振奋人心，这好似一项影响你思维的新的体验。但是首先，你必须客服你的惯性，一旦你做到了，你便开启了从web的每个角落学习知识的旅程。 原文链接","tags":[{"name":"learn","slug":"learn","permalink":"http://liaozhenzhen.github.io/tags/learn/"},{"name":"suggestion","slug":"suggestion","permalink":"http://liaozhenzhen.github.io/tags/suggestion/"}]},{"title":"LESS-语言特性","date":"2016-11-13T06:51:00.000Z","path":"2016/11/13/less-first/","text":"什么是less？ less是一种动态样式语言，属于CSS预处理语言的一种，它使用类似CSS的语法，为CSS赋予了动态语言的特征，比如变量、继承、运算、函数等，这使得学习less更轻松，一旦遇到任何问题，可以随时退回使用标准的CSS。 变量（Variables）less代码：1234@color:purplediv&#123; color:@color;&#125; 编译后：123div&#123; color:purple;&#125; 在这里 @color:purple 这个变量只能定义一次，以后需要使用就直接 属性名:@color ，就会自动把value值编译成purple。 混合（Mixins）混合可以将定义好的class A轻松的引入到另一个class B中，从而简单实现class B继承class A中所有属性。我们还可以带参数地调用，就像使用函数一样。less代码：1234567891011121314151617@border:1px solid red;@width:100px;@height:100px;.box&#123; border:@border; width:@width; height:@height;&#125;.div1&#123; .box; background:purple;&#125;.div2&#123; .box; background:blue;&#125; 编译后：1234567891011121314151617.box&#123; border:1px solid red; width:100px; height:100px;&#125;.div1&#123; border:1px solid red; width:100px; height:100px; background:purple;&#125;.div2&#123; border:1px solid red; width:100px; height:100px; background:blue;&#125; 嵌套规则(Nested rules)我们可以在一个选择器中嵌套另一个选择器来实现继承，这样很大程度的减少了代码量，并且代码看起来更加的清晰。less代码1234567891011.header&#123; color:#ddd; .nav&#123; background:purple; font-size:16px; div&#123; width:100px; height:100px; &#125; &#125;&#125; 编译后：1234567891011.header&#123; color:#ddd;&#125;.header .nav&#123; background:purple; font-size:16px;&#125;.header .nav div&#123; width:100px; height:100px;&#125; 如上的less代码建构更加清晰。说实话我就特喜欢它这一点。使用这种方法一样可以在混合中包含伪类（pseudo-selectors）。下面是一个经典的clearfix代码，在这里使用mixin重写了（&amp; 表示当前选择器的父选择器）:123456789101112.clearfix&#123; display:block; zoom:1; &amp;:after&#123; content:&quot;&quot;; display:block; font-size:0; height:0; clear:both; visiblity:hidden; &#125;&#125; 冒泡和嵌套媒体查询媒体查询可以嵌套的方式和选择器相同，选择器都被复制到媒体查询的主体中：1234567891011.screencolor&#123; @media srceen&#123; color:green; @media(min-width:760px)&#123; color:red; &#125; &#125; @media tv&#123; color:black; &#125;&#125; 编译后：123456789101112131415@media screen&#123; .screencolor&#123; color:green; &#125;&#125;@media screen and (min-width:760px)&#123; .screencolor&#123; color:red; &#125;&#125;@media tv&#123; .screencolor&#123; color:block; &#125;&#125; 运算(Operation)运算提供了加、减、乘、除操作，我们可以做属性值和颜色的运算。less代码123456789@width:100px;@border:1px solid red;@color:#111;.header&#123; width:@width*1.2; border:@border; height:@width/2; color:@color*2&#125; 编译后代码：123456.header&#123; width:120px; border:1px solid red; height:50px; color:#222;&#125; 因为在@width 的时候已经写了单位”px”,所以在后面调用它的时候，value就不需要再写单位了。反之，如果在定义一个常量的时候没有带单位，那么在使用它的时候就需要在它的后面写上单位了。 函数（Functions）less提供了许多用于转化颜色，处理字符串和进行算术运算的函数。下面的例子很经典的描述了函数在less中的使用：lee代码1234567@base:#f04615;@width:0.5;.class&#123; width:parcetage(@width); //return`50%` color:saturate(@base,5%); background-color:spin(lighten(@base,25%),8);&#125; 在这个例子中我们使用parcentage将0.5转化为50%，然后将基础颜色值的饱和度增加了5%，最后将背景颜色的亮度增加了25%之后又将色相值增加了8.","tags":[{"name":"CSS","slug":"CSS","permalink":"http://liaozhenzhen.github.io/tags/CSS/"},{"name":"Less","slug":"Less","permalink":"http://liaozhenzhen.github.io/tags/Less/"}]}]